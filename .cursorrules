# Cursor Rules for NestJS Timesheet Management System

## Core Development Principles

- **Stability First**: Prioritize working, stable code over optimization
- **Error Prevention**: Always check for potential errors and edge cases
- **Consistency**: Follow existing patterns and conventions in the codebase
- **Practical Code**: Focus on maintainable, readable solutions

## Project Architecture Guidelines

### NestJS Structure

- Follow the established module structure: `src/modules/[feature]/`
- Each module should have: controller, service, DTOs, entities (if needed)
- Use proper dependency injection patterns
- Import `PrismaModule` in every feature module that needs database access

### Database & Prisma

- Always use UUIDs for primary keys (already migrated in this project)
- Use transactions for operations that modify multiple tables
- Handle Prisma error codes properly:
  - `P2002`: Unique constraint violation ‚Üí `ConflictException`
  - `P2025`: Record not found ‚Üí `NotFoundException`
  - `P2003`: Foreign key constraint ‚Üí `BadRequestException`
- Always include relevant relations in queries when needed for the response

### Error Handling

- Use appropriate NestJS exceptions:
  - `BadRequestException` for validation errors
  - `NotFoundException` for missing resources
  - `ConflictException` for duplicate data
  - `ForbiddenException` for authorization issues
  - `UnauthorizedException` for authentication issues
  - `InternalServerErrorException` for unexpected errors
- Wrap try-catch around database operations
- Provide meaningful error messages to users
- Log detailed errors for debugging but return sanitized messages to clients

## Code Standards

### Validation & DTOs

- Use Zod schemas for all DTOs (following existing pattern)
- Export both schema and inferred type: `export type CreateXDto = z.infer<typeof createXSchema>;`
- Validate all inputs, especially:
  - UUID format for IDs
  - Date formats and ranges
  - Required fields for different request types
  - Business logic constraints (e.g., end_date >= start_date)

### Service Layer

- Always validate user permissions in service methods
- Check if entities exist before operations
- Use descriptive method names: `createRequest`, `responseTimesheet`, `getUserStats`
- Implement proper pagination with `skip` and `take`
- Include search and filtering capabilities where appropriate

### Controller Layer

- Use proper HTTP methods and status codes
- Implement role-based guards: `@Roles('ADMIN', 'HR')` or `@RoleOptions({ allowSelfAccess: true })`
- Use `@GetUser('id')` decorator to get current user ID
- Return standardized responses using `ApiResponse` and `PaginatedResponse`
- Add audit logging with `@AuditLog()` decorator for important operations

### Authentication & Authorization

- All endpoints must be protected by default (using global `JwtAuthGuard`)
- Use `@Public()` decorator only for auth endpoints (login, register, google auth)
- Implement proper role checking with enhanced role guard
- Allow self-access where appropriate using `@RoleOptions({ allowSelfAccess: true, paramName: 'id' })`
- Always verify user is active before allowing operations

## Specific Patterns to Follow

### Database Queries

```typescript
// Always handle pagination
const skip = (Number(page) - 1) * Number(limit);
const [total, items] = await Promise.all([
  this.prisma.model.count({ where }),
  this.prisma.model.findMany({ where, skip, take: Number(limit), orderBy }),
]);

// Always include necessary relations
const item = await this.prisma.model.findUnique({
  where: { id },
  include: {
    relatedModel: { select: { id: true, name: true } },
    _count: { select: { children: true } },
  },
});
```

### Error Handling Pattern

```typescript
try {
  const result = await this.prisma.model.create({ data });
  return result;
} catch (error) {
  if (error.code === 'P2002') {
    throw new ConflictException(
      `Item with this ${error.meta?.target?.[0]} already exists`,
    );
  }
  if (error.code === 'P2025') {
    throw new NotFoundException(`Item with ID ${id} not found`);
  }
  throw new InternalServerErrorException('Failed to create item');
}
```

### Controller Response Pattern

```typescript
@Get()
@Roles('ADMIN', 'HR')
async findAll(@Query() query: any) {
  const result = await this.service.findAll(query);
  return new PaginatedResponse(
    result.data,
    result.pagination,
    'Items retrieved successfully'
  );
}

@Get(':id')
@RoleOptions({ allowSelfAccess: true, paramName: 'id' })
async findOne(@Param('id') id: string) {
  const item = await this.service.findOne(id);
  return new ApiResponse(item, 'Item retrieved successfully');
}
```

## Security Considerations

- Never return password fields in responses
- Validate UUIDs before database queries
- Check user permissions before any data access
- Sanitize user inputs to prevent injection attacks
- Use transactions for operations that modify multiple related records

## Common Pitfalls to Avoid

- Don't forget to check if user/resource exists before operations
- Don't expose sensitive data in error messages
- Don't skip validation on optional fields that have business rules
- Don't forget to handle the case where user is inactive
- Don't use hardcoded role names - use the established role checking pattern
- Don't skip audit logging on important operations
- Don't forget to handle overlapping date ranges in time-based features

## Testing Approach

- Write tests for edge cases and error scenarios first
- Test authentication and authorization thoroughly
- Verify error handling returns appropriate HTTP status codes
- Test data validation with invalid inputs
- Ensure audit logs are created for tracked operations

## Performance Guidelines

- Use `select` to limit returned fields when not all are needed
- Implement proper indexing in Prisma schema for frequently queried fields
- Use `include` judiciously - only include what's needed for the response
- Consider using `_count` instead of fetching full relations when only count is needed
- Batch database operations when possible

## Code Review Checklist

- [ ] Proper error handling with try-catch
- [ ] Input validation with Zod schemas
- [ ] Appropriate HTTP status codes and exceptions
- [ ] Role-based access control implemented
- [ ] Audit logging for important operations
- [ ] Database transactions for multi-table operations
- [ ] Pagination implemented where applicable
- [ ] User existence and activity checks
- [ ] UUID validation for ID parameters
- [ ] Consistent response format using ApiResponse/PaginatedResponse

Remember: **Code that works reliably is better than code that's perfectly optimized but breaks in edge cases.**

# Timesheet Management Backend - Cursor Rules

## üéØ **Project Context**

This is a comprehensive **NestJS backend** for a timesheet management system with enterprise-grade features including:

- **JWT Authentication** with Google OAuth integration
- **Role-based Access Control** with enhanced permissions
- **Audit Logging** for compliance and security tracking
- **Prisma ORM** with PostgreSQL database
- **Zod Validation** for request/response schemas
- **Swagger Documentation** for API documentation
- **Modular Architecture** with domain-driven design

## üèóÔ∏è **Architecture Patterns**

### **Module Structure**

```
src/
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ auth/                  # Authentication & authorization
‚îÇ   ‚îú‚îÄ‚îÄ users/                 # User management
‚îÇ   ‚îú‚îÄ‚îÄ timesheets/           # Timesheet tracking
‚îÇ   ‚îú‚îÄ‚îÄ projects/             # Project management
‚îÇ   ‚îú‚îÄ‚îÄ requests/             # Leave/remote requests
‚îÇ   ‚îú‚îÄ‚îÄ working-times/        # Working schedule
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/            # Analytics & reporting
‚îÇ   ‚îî‚îÄ‚îÄ audit-logs/           # Audit & compliance
‚îú‚îÄ‚îÄ common/                   # Shared utilities
‚îú‚îÄ‚îÄ prisma/                   # Database layer
‚îî‚îÄ‚îÄ config/                   # Application configuration
```

### **Role-Based Access Control**

- **ADMIN**: Full system access
- **HR**: User management, reports, approvals
- **PM**: Project management, team oversight
- **USER**: Personal data, timesheets, requests

## üìã **Development Guidelines**

### **1. Controller Development**

**ALWAYS follow this pattern:**

```typescript
@Controller('resource-name')
@UseGuards(JwtAuthGuard, EnhancedRolesGuard)
@ApiTags('Resource Name')
@ApiBearerAuth('JWT-auth')
export class ResourceController {
  constructor(private readonly resourceService: ResourceService) {}

  @Post()
  @Roles('ADMIN', 'HR') // Specify required roles
  @AuditLog(createResourceAuditConfig()) // Add audit logging
  @ApiOperation({
    summary: 'Create resource',
    description: 'Detailed description with business rules and use cases',
  })
  async create(
    @Body() createDto: CreateResourceDto,
    @GetUser('id') userId: string,
  ) {
    const result = await this.resourceService.create(userId, createDto);
    return new ApiResponse(result.data, result.message);
  }
}
```

**Controller Best Practices:**

- Use `@UseGuards(JwtAuthGuard, EnhancedRolesGuard)` for protected routes
- Always specify `@Roles()` decorator for role-based access
- Add `@AuditLog()` decorator for trackable actions
- Use `@GetUser()` decorator to get authenticated user
- Return standardized `ApiResponse` or `PaginatedResponse`
- Include comprehensive Swagger documentation

### **2. Service Development**

**Service Pattern:**

```typescript
@Injectable()
export class ResourceService {
  constructor(private prisma: PrismaService) {}

  async create(userId: string, createDto: CreateResourceDto) {
    // 1. Validate business rules
    await this.validateBusinessRules(createDto);

    // 2. Perform database operation
    const resource = await this.prisma.resource.create({
      data: {
        ...createDto,
        user_id: userId,
      },
      include: {
        user: { select: { id: true, name: true, surname: true } },
        // Include related data as needed
      },
    });

    // 3. Return structured response
    return {
      data: resource,
      message: 'Resource created successfully',
    };
  }

  private async validateBusinessRules(data: CreateResourceDto) {
    // Implement business logic validation
    // Throw appropriate exceptions for violations
  }
}
```

**Service Best Practices:**

- Always validate business rules before database operations
- Use Prisma's `include` to fetch related data efficiently
- Return structured objects with `data` and `message` properties
- Handle errors gracefully with appropriate HTTP status codes
- Use private methods for business logic validation

### **3. DTO Development**

**Create comprehensive DTOs with Zod validation:**

```typescript
import { z } from 'zod';
import { createZodDto } from '@anatine/zod-nestjs';

export const createResourceSchema = z.object({
  name: z
    .string()
    .min(2, 'Name must be at least 2 characters')
    .max(100, 'Name must not exceed 100 characters')
    .trim(),
  description: z
    .string()
    .max(1000, 'Description must not exceed 1000 characters')
    .optional(),
  status: z.enum(['ACTIVE', 'INACTIVE']).default('ACTIVE'),
  // Add more fields as needed
});

export class CreateResourceDto extends createZodDto(createResourceSchema) {
  @ApiProperty({
    description: 'Resource name',
    example: 'Project Alpha',
    minLength: 2,
    maxLength: 100,
  })
  name: string;

  @ApiProperty({
    description: 'Resource description',
    example: 'Description of the resource',
    maxLength: 1000,
    required: false,
  })
  description?: string;
}
```

**DTO Best Practices:**

- Use Zod for runtime validation
- Add comprehensive `@ApiProperty` decorators
- Include validation messages and constraints
- Use `createZodDto` for automatic Swagger integration
- Create separate DTOs for create, update, and query operations

### **4. Authentication & Authorization**

**Enhanced Roles Guard Usage:**

```typescript
@Get('sensitive-data')
@Roles('ADMIN', 'HR')
@RoleOptions({
  allowSelfAccess: true,
  paramName: 'userId',
  message: 'You can only access your own data',
  enableLogging: process.env.NODE_ENV === 'development'
})
async getData(@Param('userId') userId: string, @GetUser() user: User) {
  // Implementation
}
```

**Authentication Best Practices:**

- Use `@Roles()` decorator to specify required roles
- Use `@RoleOptions()` for self-access permissions
- Enable logging in development for debugging
- Use `@GetUser()` decorator to access authenticated user
- Implement proper error messages for unauthorized access

### **5. Audit Logging**

**Implement comprehensive audit logging:**

```typescript
@AuditLog({
  tableName: 'timesheets',
  action: 'CREATE',
  getRecordId: (result: any) => result.data?.id,
  getDetails: (result: any, request: any) => ({
    timesheet_date: result.data?.date,
    working_hours: result.data?.working_time,
    project_id: result.data?.project_id,
    user_id: result.data?.user_id
  })
})
```

**Audit Logging Best Practices:**

- Add audit logs for all create, update, delete operations
- Include relevant details for compliance tracking
- Use dynamic functions for record ID and details
- Follow consistent naming conventions
- Include business-relevant information in details

### **6. Database Operations**

**Prisma Best Practices:**

```typescript
// Use transactions for multiple operations
await this.prisma.$transaction(async (prisma) => {
  const timesheet = await prisma.timesheet.create({ data: timesheetData });
  await prisma.auditLog.create({ data: auditData });
  return timesheet;
});

// Use proper includes for related data
const timesheets = await this.prisma.timesheet.findMany({
  include: {
    user: { select: { id: true, name: true, surname: true } },
    project: { select: { id: true, project_name: true } },
    task: { select: { id: true, task_name: true } },
  },
  where: filterConditions,
  orderBy: { created_at: 'desc' },
  skip: (page - 1) * limit,
  take: limit,
});

// Handle pagination properly
const total = await this.prisma.timesheet.count({ where: filterConditions });
const pagination = {
  page,
  limit,
  total,
  totalPages: Math.ceil(total / limit),
};
```

### **7. Error Handling**

**Implement comprehensive error handling:**

```typescript
try {
  // Database operation
} catch (error) {
  if (error.code === 'P2002') {
    throw new ConflictException('Resource already exists');
  }
  if (error.code === 'P2025') {
    throw new NotFoundException('Resource not found');
  }
  throw new InternalServerErrorException('An unexpected error occurred');
}
```

**Error Handling Best Practices:**

- Use appropriate HTTP status codes
- Provide meaningful error messages
- Log errors for debugging
- Handle Prisma-specific errors
- Don't expose sensitive information in error messages

### **8. Swagger Documentation**

**Comprehensive API documentation:**

```typescript
@ApiOperation({
  summary: 'Create a new timesheet entry',
  description: `
    Creates a new timesheet entry for the authenticated user.

    **Business Rules:**
    - Users can only create timesheets for themselves
    - Working time cannot exceed 24 hours per day
    - Date must be in YYYY-MM-DD format
    - Project and task are optional for general work

    **Validation:**
    - Date format validation
    - Working time range validation
    - Project/task existence validation
  `
})
@ApiResponse({
  status: 201,
  description: 'Timesheet created successfully',
  type: ApiResponse<Timesheet>
})
@ApiBadRequestResponse({
  description: 'Validation errors',
  type: ValidationErrorResponse
})
```

### **9. Query Operations**

**Implement comprehensive filtering and pagination:**

```typescript
async findAll(userId: string, query: QueryTimesheetsDto, userRole: string) {
  const { page = 1, limit = 10, status, type, start_date, end_date } = query

  const where: Prisma.TimesheetWhereInput = {
    // Apply role-based filtering
    ...(userRole === 'USER' && { user_id: userId }),
    ...(status && { status }),
    ...(type && { type }),
    ...(start_date && end_date && {
      date: {
        gte: new Date(start_date),
        lte: new Date(end_date)
      }
    })
  }

  const [data, total] = await Promise.all([
    this.prisma.timesheet.findMany({
      where,
      include: {
        user: { select: { id: true, name: true, surname: true } },
        project: { select: { id: true, project_name: true } },
        task: { select: { id: true, task_name: true } }
      },
      orderBy: { date: 'desc' },
      skip: (page - 1) * limit,
      take: limit
    }),
    this.prisma.timesheet.count({ where })
  ])

  return {
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  }
}
```

### **10. Environment Configuration**

**Use type-safe configuration:**

```typescript
// config/database.config.ts
export default registerAs('database', () => ({
  url: process.env.DATABASE_URL,
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT, 10) || 5432,
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
}));

// config/jwt.config.ts
export default registerAs('jwt', () => ({
  secret: process.env.JWT_SECRET,
  expiresIn: process.env.JWT_EXPIRES_IN || '1d',
}));
```

## üõ°Ô∏è **Security Best Practices**

### **Authentication Security**

- Always use `@UseGuards(JwtAuthGuard, EnhancedRolesGuard)` for protected routes
- Implement proper token validation and refresh
- Use strong JWT secrets and appropriate expiration times
- Log authentication attempts for security monitoring

### **Authorization Security**

- Implement role-based access control at the controller level
- Use self-access permissions for user-specific data
- Validate user permissions at the service level
- Implement proper error handling for unauthorized access

### **Data Validation**

- Use Zod schemas for runtime validation
- Validate all input data at the DTO level
- Implement business rule validation in services
- Sanitize input data to prevent injection attacks

## üìä **Performance Optimization**

### **Database Optimization**

- Use proper indexes on frequently queried fields
- Implement efficient pagination with skip/take
- Use select and include strategically
- Implement connection pooling for database connections

### **Caching Strategy**

- Implement Redis caching for frequently accessed data
- Use database-level caching for static data
- Implement proper cache invalidation strategies
- Monitor cache hit rates and performance

## üß™ **Testing Guidelines**

### **Unit Testing**

- Test all service methods with proper mocking
- Test controller endpoints with authentication
- Test DTO validation with various inputs
- Test error handling scenarios

### **Integration Testing**

- Test complete request/response cycles
- Test database interactions with test database
- Test authentication and authorization flows
- Test audit logging functionality

## üîÑ **Development Workflow**

### **Code Organization**

- Follow the modular architecture pattern
- Keep controllers thin and services focused
- Use dependency injection consistently
- Implement proper error boundaries

### **Documentation**

- Update Swagger documentation for all endpoints
- Document business rules and validation logic
- Include usage examples in API documentation
- Maintain up-to-date README files

## üìù **Naming Conventions**

### **Files and Directories**

- Use kebab-case for file names: `user-management.service.ts`
- Use PascalCase for class names: `UserManagementService`
- Use camelCase for method names: `findUserById`
- Use UPPER_SNAKE_CASE for constants: `MAX_RETRY_ATTEMPTS`

### **Database Conventions**

- Use snake_case for table and column names
- Use descriptive foreign key names: `user_id`, `project_id`
- Use consistent naming for timestamps: `created_at`, `updated_at`
- Use plural names for tables: `users`, `timesheets`

## üöÄ **Deployment Considerations**

### **Environment Variables**

- Use `.env` files for configuration
- Validate environment variables at startup
- Use different configurations for different environments
- Keep sensitive data in environment variables

### **Production Readiness**

- Implement proper health checks
- Set up monitoring and alerting
- Configure proper logging levels
- Implement graceful shutdown handling

## üéØ **Code Quality Standards**

### **TypeScript Usage**

- Use strict TypeScript configuration
- Avoid `any` type usage
- Implement proper type definitions
- Use interfaces for data structures

### **Error Handling**

- Use appropriate HTTP status codes
- Implement global exception filters
- Log errors with proper context
- Provide meaningful error messages

### **Code Style**

- Follow consistent code formatting
- Use meaningful variable and function names
- Implement proper code comments
- Keep functions focused and small

Remember to always think like a senior NestJS developer focused on:

- **Security**: Implement proper authentication and authorization
- **Performance**: Optimize database queries and implement caching
- **Maintainability**: Write clean, modular, and testable code
- **Documentation**: Provide comprehensive API documentation
- **Error Handling**: Implement robust error handling and logging
- **Business Logic**: Focus on business rules and validation
- **Scalability**: Design for growth and maintainability
